これは式の構文木を生成するための
テンプレートヘッダーです
中置記法で並んだ、ユーザー定義のElement型を
後置記法の並びに変換して、二分木構造にします




テンプレートに渡すElement型の要件は以下の通り
・ElementKind型への変換ができる
・Precedence型への変換ができる
・Associativity型への変換ができる


ElementKindはElement型の種類を指示するenum型です
種類は以下の通り
・operand(被演算子)
・unary_operator(単項演算子)
・binary_operator(二項演算子)
いまのところ単項演算子は前置のみで、後置には未対応


Precedenceは演算子の優先順位を指示する型です


Associativityは演算子の結合性を指示するenum型です
種類は以下の通り
・none
・left_to_right(左から右へ)
・right_to_left(右から左へ)
演算子の結合性は、優先順位が同一の場合の演算順位に関係します
例えば、a+b+c+dという式の場合
left_to_rightなら、((a+b)+c)+d
right_to_leftなら、a+(b+(c+d))
となります




使い方：
中置記法で並んだstd::vector<Element>をto_rpn関数へムーブで渡します
すると、各Elementをムーブしてnewした、後置記法のstd::list<Node*>となって返ります

さらにそれを、create_tree関数へムーブで渡します
すると、二分木のルートノードが返ります
これを使い終えたら、deleteしてください




